{
    "contents" : "// GBM by Greg Ridgeway  Copyright (C) 2003\n\n#include \"gbm.h\"\n\nextern \"C\" {\n\n#include <R.h>\n#include <Rinternals.h>\n\nSEXP gbm\n(\n    SEXP radY,       // outcome or response\n    SEXP radOffset,  // offset for f(x), NA for no offset\n    SEXP radX,        \n    SEXP raiXOrder,        \n    SEXP radWeight,\n    SEXP radMisc,   // other row specific data (eg failure time), NA=no Misc\n    SEXP rcRows,\n    SEXP rcCols,\n    SEXP racVarClasses,\n    SEXP ralMonotoneVar,\n    SEXP rszFamily, \n    SEXP rcTrees,\n    SEXP rcDepth,       // interaction depth\n    SEXP rcMinObsInNode,\n    SEXP rcNumClasses,\n    SEXP rdShrinkage,\n    SEXP rdBagFraction,\n    SEXP rcTrain,\n    SEXP rcFeatures,\n    SEXP radFOld,\n    SEXP rcCatSplitsOld,\n    SEXP rcTreesOld,\n    SEXP rfVerbose\n)\n{\n    unsigned long hr = 0;\n\n    SEXP rAns = NULL;\n    SEXP rNewTree = NULL;\n    SEXP riSplitVar = NULL;\n    SEXP rdSplitPoint = NULL;\n    SEXP riLeftNode = NULL;\n    SEXP riRightNode = NULL;\n    SEXP riMissingNode = NULL;\n    SEXP rdErrorReduction = NULL;\n    SEXP rdWeight = NULL;\n    SEXP rdPred = NULL;\n\n    SEXP rdInitF = NULL;\n    SEXP radF = NULL;\n    SEXP radTrainError = NULL;\n    SEXP radValidError = NULL;\n    SEXP radOOBagImprove = NULL;\n\n    SEXP rSetOfTrees = NULL;\n    SEXP rSetSplitCodes = NULL;\n    SEXP rSplitCode = NULL;\n\n    VEC_VEC_CATEGORIES vecSplitCodes;\n\n    int i = 0;\n    int iT = 0;\n    int iK = 0;\n    int cTrees = INTEGER(rcTrees)[0];\n    const int cResultComponents = 7;\n    // rdInitF, radF, radTrainError, radValidError, radOOBagImprove\n    // rSetOfTrees, rSetSplitCodes\n    const int cTreeComponents = 8;\n    // riSplitVar, rdSplitPoint, riLeftNode,\n    // riRightNode, riMissingNode, rdErrorReduction, rdWeight, rdPred\n    int cNodes = 0;\n    int cTrain = INTEGER(rcTrain)[0];\n    int cFeatures = INTEGER(rcFeatures)[0];\n    int cNumClasses = INTEGER(rcNumClasses)[0];\n\n    double dTrainError = 0.0;\n    double dValidError = 0.0;\n    double dOOBagImprove = 0.0;\n\n    CGBM *pGBM = NULL;\n    CDataset *pData = NULL;\n    CDistribution *pDist = NULL;\n    int cGroups = -1;\n\n    // set up the dataset\n    pData = new CDataset();\n\n    // initialize R's random number generator\n    GetRNGstate();\n\n    // initialize some things\n    hr = gbm_setup(REAL(radY),\n                   REAL(radOffset),\n                   REAL(radX),\n                   INTEGER(raiXOrder),\n                   REAL(radWeight),\n                   REAL(radMisc),\n                   INTEGER(rcRows)[0],\n                   INTEGER(rcCols)[0],\n                   INTEGER(racVarClasses),\n                   INTEGER(ralMonotoneVar),\n                   CHAR(STRING_ELT(rszFamily,0)),\n                   INTEGER(rcTrees)[0],\n                   INTEGER(rcDepth)[0],\n                   INTEGER(rcMinObsInNode)[0],\n                   INTEGER(rcNumClasses)[0],\n                   REAL(rdShrinkage)[0],\n                   REAL(rdBagFraction)[0],\n                   INTEGER(rcTrain)[0],\n\t\t\t\t   //INTEGER(rcFeatures)[0],\n                   pData,\n                   pDist,\n                   cGroups);\n\n    if(GBM_FAILED(hr))\n    {\n        goto Error;\n    }\n       \n    // allocate the GBM\n    pGBM = new CGBM();\n\n    // initialize the GBM\n    hr = pGBM->Initialize(pData,\n                          pDist,\n                          REAL(rdShrinkage)[0], \n                          cTrain, \n                          cFeatures,\n                          REAL(rdBagFraction)[0],\n                          INTEGER(rcDepth)[0],\n                          INTEGER(rcMinObsInNode)[0],\n                          INTEGER(rcNumClasses)[0],\n                          cGroups);\n\n    if(GBM_FAILED(hr))\n    {\n        goto Error;\n    }\n\n    // allocate the main return object\n    PROTECT(rAns = allocVector(VECSXP, cResultComponents));\n\n    // allocate the initial value\n    PROTECT(rdInitF = allocVector(REALSXP, 1));\n    SET_VECTOR_ELT(rAns,0,rdInitF);\n    UNPROTECT(1); // rdInitF\n\n    // allocate the predictions\n    PROTECT(radF = allocVector(REALSXP, (pData->cRows) * cNumClasses));\n    SET_VECTOR_ELT(rAns,1,radF);\n    UNPROTECT(1); // radF\n\n    hr = pDist->Initialize(pData->adY,\n                           pData->adMisc,\n                           pData->adOffset,\n                           pData->adWeight,\n                           pData->cRows);\n\n    if(ISNA(REAL(radFOld)[0])) // check for old predictions\n    {\n        // set the initial value of F as a constant\n        hr = pDist->InitF(pData->adY,\n                          pData->adMisc,\n                          pData->adOffset,\n                          pData->adWeight,\n                          REAL(rdInitF)[0], \n                          cTrain);\n\n        for(i=0; i < (pData->cRows) * cNumClasses; i++)\n        {\n            REAL(radF)[i] = REAL(rdInitF)[0];\n        }\n    }\n    else\n    {\n        for(i=0; i < (pData->cRows) * cNumClasses; i++)\n        {\n            REAL(radF)[i] = REAL(radFOld)[i];\n        }\n    }\n\n    // allocate space for the performance measures\n    PROTECT(radTrainError = allocVector(REALSXP, cTrees));\n    PROTECT(radValidError = allocVector(REALSXP, cTrees));\n    PROTECT(radOOBagImprove = allocVector(REALSXP, cTrees));\n    SET_VECTOR_ELT(rAns,2,radTrainError);\n    SET_VECTOR_ELT(rAns,3,radValidError);\n    SET_VECTOR_ELT(rAns,4,radOOBagImprove);\n    UNPROTECT(3); // radTrainError , radValidError, radOOBagImprove\n\n    // allocate the component for the tree structures\n    PROTECT(rSetOfTrees = allocVector(VECSXP, cTrees * cNumClasses));\n    SET_VECTOR_ELT(rAns,5,rSetOfTrees);\n    UNPROTECT(1); // rSetOfTrees\n\n    if(INTEGER(rfVerbose)[0])\n    {\n       Rprintf(\"Iter   TrainDeviance   ValidDeviance   StepSize   Improve\\n\");\n    }\n    for(iT=0; iT<cTrees; iT++)\n    {\n        // Update the parameters\n        hr = pDist->UpdateParams(REAL(radF), pData->adOffset, pData->adWeight, cTrain);\n\n        if(GBM_FAILED(hr))\n        {\n           goto Error;\n        }\n        REAL(radTrainError)[iT] = 0.0;\n        REAL(radValidError)[iT] = 0.0;\n        REAL(radOOBagImprove)[iT] = 0.0;\n        for (iK = 0; iK < cNumClasses; iK++)\n        {\n            hr = pGBM->iterate(REAL(radF),\n                               dTrainError,dValidError,dOOBagImprove,\n                               cNodes, cNumClasses, iK);\n\n            if(GBM_FAILED(hr))\n            {\n                goto Error;\n            }\n\n            // store the performance measures\n            REAL(radTrainError)[iT] += dTrainError;\n            REAL(radValidError)[iT] += dValidError;\n            REAL(radOOBagImprove)[iT] += dOOBagImprove;\n\n            // allocate the new tree component for the R list structure\n            PROTECT(rNewTree = allocVector(VECSXP, cTreeComponents));\n            // riNodeID,riSplitVar,rdSplitPoint,riLeftNode,\n            // riRightNode,riMissingNode,rdErrorReduction,rdWeight\n            PROTECT(riSplitVar = allocVector(INTSXP, cNodes));\n            PROTECT(rdSplitPoint = allocVector(REALSXP, cNodes));\n            PROTECT(riLeftNode = allocVector(INTSXP, cNodes));\n            PROTECT(riRightNode = allocVector(INTSXP, cNodes));\n            PROTECT(riMissingNode = allocVector(INTSXP, cNodes));\n            PROTECT(rdErrorReduction = allocVector(REALSXP, cNodes));\n            PROTECT(rdWeight = allocVector(REALSXP, cNodes));\n            PROTECT(rdPred = allocVector(REALSXP, cNodes));\n            SET_VECTOR_ELT(rNewTree,0,riSplitVar);\n            SET_VECTOR_ELT(rNewTree,1,rdSplitPoint);\n            SET_VECTOR_ELT(rNewTree,2,riLeftNode);\n            SET_VECTOR_ELT(rNewTree,3,riRightNode);\n            SET_VECTOR_ELT(rNewTree,4,riMissingNode);\n            SET_VECTOR_ELT(rNewTree,5,rdErrorReduction);\n            SET_VECTOR_ELT(rNewTree,6,rdWeight);\n            SET_VECTOR_ELT(rNewTree,7,rdPred);\n            UNPROTECT(cTreeComponents); \n            SET_VECTOR_ELT(rSetOfTrees,(iK + iT * cNumClasses),rNewTree);\n            UNPROTECT(1); // rNewTree\n        \n            hr = gbm_transfer_to_R(pGBM,\n                                   vecSplitCodes,\n                                   INTEGER(riSplitVar),\n                                   REAL(rdSplitPoint),\n                                   INTEGER(riLeftNode),\n                                   INTEGER(riRightNode),\n                                   INTEGER(riMissingNode),\n                                   REAL(rdErrorReduction),\n                                   REAL(rdWeight),\n                                   REAL(rdPred),\n                                   INTEGER(rcCatSplitsOld)[0]);\n        } // Close for iK\n\n        // print the information\n        if((iT <= 9) ||\n           ((iT+1+INTEGER(rcTreesOld)[0])/20 ==\n            (iT+1+INTEGER(rcTreesOld)[0])/20.0) ||\n            (iT==cTrees-1))\n        {\n            R_CheckUserInterrupt();\n            if(INTEGER(rfVerbose)[0])\n            {\n               Rprintf(\"%6d %13.4f %15.4f %10.4f %9.4f\\n\",\n                       iT+1+INTEGER(rcTreesOld)[0],\n                       REAL(radTrainError)[iT],\n                       REAL(radValidError)[iT],\n                       REAL(rdShrinkage)[0],\n                       REAL(radOOBagImprove)[iT]);\n            }\n        }\n    }\n\n    if(INTEGER(rfVerbose)[0]) Rprintf(\"\\n\");\n\n    // transfer categorical splits to R\n    PROTECT(rSetSplitCodes = allocVector(VECSXP, vecSplitCodes.size()));\n    SET_VECTOR_ELT(rAns,6,rSetSplitCodes);\n    UNPROTECT(1); // rSetSplitCodes\n\n    for(i=0; i<(int)vecSplitCodes.size(); i++)\n    {\n        PROTECT(rSplitCode = \n                    allocVector(INTSXP, size_of_vector(vecSplitCodes,i)));\n        SET_VECTOR_ELT(rSetSplitCodes,i,rSplitCode);\n        UNPROTECT(1); // rSplitCode\n\n        hr = gbm_transfer_catsplits_to_R(i,\n                                         vecSplitCodes,\n                                         INTEGER(rSplitCode));\n    }\n\n    // dump random number generator seed\n    #ifdef NOISY_DEBUG\n    Rprintf(\"PutRNGstate\\n\");\n    #endif\n    PutRNGstate();\n\nCleanup:\n    UNPROTECT(1); // rAns\n    #ifdef NOISY_DEBUG\n    Rprintf(\"destructing\\n\");\n    #endif\n\n    delete pGBM;\n    delete pDist;\n    delete pData;\n\n    return rAns;\nError:\n    goto Cleanup;\n}\n\nSEXP gbm_pred\n(\n   SEXP radX,         // the data matrix\n   SEXP rcRows,       // number of rows\n   SEXP rcCols,       // number of columns\n   SEXP rcNumClasses, // number of classes\n   SEXP rcTrees,      // number of trees, may be a vector\n   SEXP rdInitF,      // the initial value\n   SEXP rTrees,       // the list of trees\n   SEXP rCSplits,     // the list of categorical splits\n   SEXP raiVarType,   // indicator of continuous/nominal\n   SEXP riSingleTree  // boolean whether to return only results for one tree\n)\n{\n   unsigned long hr = 0;\n   int iTree = 0;\n   int iObs = 0;\n   int cRows = INTEGER(rcRows)[0];\n   int cPredIterations = LENGTH(rcTrees);\n   int iPredIteration = 0;\n   int cTrees = 0;\n   int iClass = 0;\n   int cNumClasses = INTEGER(rcNumClasses)[0];\n\n   SEXP rThisTree = NULL;\n   int *aiSplitVar = NULL;\n   double *adSplitCode = NULL;\n   int *aiLeftNode = NULL;\n   int *aiRightNode = NULL;\n   int *aiMissingNode = NULL;\n   int iCurrentNode = 0;\n   double dX = 0.0;\n   int iCatSplitIndicator = 0;\n   bool fSingleTree = (INTEGER(riSingleTree)[0]==1);\n\n   SEXP radPredF = NULL;\n\n   // allocate the predictions to return\n   PROTECT(radPredF = allocVector(REALSXP, cRows*cNumClasses*cPredIterations));\n   if(radPredF == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n\n   // initialize the predicted values\n   if(!fSingleTree)\n   {\n      // initialize with the intercept for only the smallest rcTrees\n      for(iObs=0; iObs<cRows*cNumClasses; iObs++)\n      {\n         REAL(radPredF)[iObs] = REAL(rdInitF)[0];\n      }\n   }\n   else\n   {\n      for(iObs=0; iObs<cRows*cNumClasses*cPredIterations; iObs++)\n      {\n         REAL(radPredF)[iObs] = 0.0;\n      }\n   }\n\n   iTree = 0;\n   for(iPredIteration=0; iPredIteration<LENGTH(rcTrees); iPredIteration++)\n   {\n      cTrees = INTEGER(rcTrees)[iPredIteration];\n      if(fSingleTree) iTree=cTrees-1;\n      if(!fSingleTree && (iPredIteration>0))\n      {\n          // copy over from the last rcTrees\n          for(iObs=0; iObs<cRows*cNumClasses; iObs++)\n          {\n             REAL(radPredF)[cRows*cNumClasses*iPredIteration+iObs] =\n                REAL(radPredF)[cRows*cNumClasses*(iPredIteration-1)+iObs];\n          }\n      }\n      while(iTree<cTrees*cNumClasses)\n      {\n         for (iClass = 0; iClass < cNumClasses; iClass++)\n         {\n            rThisTree   = VECTOR_ELT(rTrees,iTree);\n            // these relate to columns returned by pretty.gbm.tree()\n            aiSplitVar    = INTEGER(VECTOR_ELT(rThisTree,0));\n            adSplitCode   = REAL   (VECTOR_ELT(rThisTree,1));\n            aiLeftNode    = INTEGER(VECTOR_ELT(rThisTree,2));\n            aiRightNode   = INTEGER(VECTOR_ELT(rThisTree,3));\n            aiMissingNode = INTEGER(VECTOR_ELT(rThisTree,4));\n\n            for(iObs=0; iObs<cRows; iObs++)\n            {\n               iCurrentNode = 0;\n               while(aiSplitVar[iCurrentNode] != -1)\n               {\n                  dX = REAL(radX)[aiSplitVar[iCurrentNode]*cRows + iObs];\n                  // missing?\n                  if(ISNA(dX))\n                  {\n                     iCurrentNode = aiMissingNode[iCurrentNode];\n                  }\n                  // continuous?\n                  else if(INTEGER(raiVarType)[aiSplitVar[iCurrentNode]] == 0)\n                  {\n                     if(dX < adSplitCode[iCurrentNode])\n                     {\n                        iCurrentNode = aiLeftNode[iCurrentNode];\n                     }\n                     else\n                     {\n                        iCurrentNode = aiRightNode[iCurrentNode];\n                     }\n                  }\n                  else // categorical\n                  {\n                     iCatSplitIndicator = INTEGER(\n                                 VECTOR_ELT(rCSplits,\n                                            (int)adSplitCode[iCurrentNode]))[(int)dX];\n                     if(iCatSplitIndicator==-1)\n                     {\n                        iCurrentNode = aiLeftNode[iCurrentNode];\n                     }\n                     else if(iCatSplitIndicator==1)\n                     {\n                        iCurrentNode = aiRightNode[iCurrentNode]; \n                     }  \n                     else // categorical level not present in training\n                     {\n                        iCurrentNode = aiMissingNode[iCurrentNode];\n                     }\n                  }\n               }\n               REAL(radPredF)[cRows*cNumClasses*iPredIteration+cRows*iClass+iObs] += \n                  adSplitCode[iCurrentNode]; // add the prediction\n            } // iObs\n            iTree++;\n         } // iClass\n      } // iTree\n   }  // iPredIteration\n    \nCleanup:\n    UNPROTECT(1); // radPredF\n    return radPredF;\nError:\n    goto Cleanup;\n}\n\n\nSEXP gbm_plot\n(\n    SEXP radX,          // vector or matrix of points to make predictions\n    SEXP rcRows,        // number of rows in X\n    SEXP rcCols,        // number of columns in X\n    SEXP rcNumClasses,  // number of classes\n    SEXP raiWhichVar,   // length=cCols, index of which var cols of X are\n    SEXP rcTrees,       // number of trees to use\n    SEXP rdInitF,       // initial value\n    SEXP rTrees,        // tree list object\n    SEXP rCSplits,      // categorical split list object\n    SEXP raiVarType     // vector of variable types\n)\n{\n    unsigned long hr = 0;\n    int i = 0;\n    int iTree = 0;\n    int iObs = 0;\n    int iClass = 0;\n    int cRows = INTEGER(rcRows)[0];\n    int cCols = INTEGER(rcCols)[0];\n    int cTrees = INTEGER(rcTrees)[0];\n    int cNumClasses = INTEGER(rcNumClasses)[0];\n\n    SEXP rThisTree = NULL;\n    int *aiSplitVar = NULL;\n    double *adSplitCode = NULL;\n    int *aiLeftNode = NULL;\n    int *aiRightNode = NULL;\n    int *aiMissingNode = NULL;\n    double *adW = NULL;\n    int iCurrentNode = 0;\n    double dCurrentW = 0.0;\n    double dX = 0.0;\n    int iCatSplitIndicator = 0;\n\n    SEXP radPredF = NULL;\n    int aiNodeStack[40];\n    double adWeightStack[40];\n    int cStackNodes = 0;\n    int iPredVar = 0;\n\n    // allocate the predictions to return\n    PROTECT(radPredF = allocVector(REALSXP, cRows*cNumClasses));\n    if(radPredF == NULL)\n    {\n        hr = GBM_OUTOFMEMORY;\n        goto Error;\n    }\n    for(iObs=0; iObs<cRows*cNumClasses; iObs++)\n    {\n        REAL(radPredF)[iObs] = REAL(rdInitF)[0];\n    }\n    for(iTree=0; iTree<cTrees; iTree++)\n    {\n        for (iClass = 0; iClass < cNumClasses; iClass++)\n        {\n            rThisTree     = VECTOR_ELT(rTrees,iClass + iTree*cNumClasses);\n            aiSplitVar    = INTEGER(VECTOR_ELT(rThisTree,0));\n            adSplitCode   = REAL   (VECTOR_ELT(rThisTree,1));\n            aiLeftNode    = INTEGER(VECTOR_ELT(rThisTree,2));\n            aiRightNode   = INTEGER(VECTOR_ELT(rThisTree,3));\n            aiMissingNode = INTEGER(VECTOR_ELT(rThisTree,4));\n            adW           = REAL   (VECTOR_ELT(rThisTree,6));\n            for(iObs=0; iObs<cRows; iObs++)\n            {\n                aiNodeStack[0] = 0;\n                adWeightStack[0] = 1.0;\n                cStackNodes = 1;\n                while(cStackNodes > 0)\n                {\n                    cStackNodes--;\n                    iCurrentNode = aiNodeStack[cStackNodes];\n\n                    if(aiSplitVar[iCurrentNode] == -1) // terminal node\n                    {\n                        REAL(radPredF)[iClass*cRows + iObs] += \n                            adWeightStack[cStackNodes]*adSplitCode[iCurrentNode];\n                    }\n                    else // non-terminal node\n                    {\n                        // is this a split variable that interests me?\n                        iPredVar = -1;\n                        for(i=0; (iPredVar == -1) && (i < cCols); i++)\n                        {\n                            if(INTEGER(raiWhichVar)[i] == aiSplitVar[iCurrentNode])\n                            {\n                                iPredVar = i; // split is on one that interests me\n                            }\n                        }\n\n                        if(iPredVar != -1) // this split is among raiWhichVar\n                        {    \n                            dX = REAL(radX)[iPredVar*cRows + iObs];\n                            // missing?\n                            if(ISNA(dX))\n                            {\n                                aiNodeStack[cStackNodes] = aiMissingNode[iCurrentNode];\n                                cStackNodes++;                            \n                            }\n                            // continuous?\n                            else if(INTEGER(raiVarType)[aiSplitVar[iCurrentNode]] == 0)\n                                {\n                                if(dX < adSplitCode[iCurrentNode])\n                                {\n                                    aiNodeStack[cStackNodes] = aiLeftNode[iCurrentNode];\n                                        cStackNodes++;\n                                }\n                                else\n                                {\n                                    aiNodeStack[cStackNodes] = aiRightNode[iCurrentNode];\n                                    cStackNodes++;\n                                }\n                            }\n                            else // categorical\n                            {\n                                iCatSplitIndicator = INTEGER(\n                                    VECTOR_ELT(rCSplits,\n                                               (int)adSplitCode[iCurrentNode]))[(int)dX];\n                                if(iCatSplitIndicator==-1)\n                                {\n                                    aiNodeStack[cStackNodes] = aiLeftNode[iCurrentNode];\n                                    cStackNodes++;\n                                }\n                                else if(iCatSplitIndicator==1)\n                                {\n                                    aiNodeStack[cStackNodes] = aiRightNode[iCurrentNode];\n                                    cStackNodes++;\n                                }\n                                else // handle unused level\n                                {\n                                    iCurrentNode = aiMissingNode[iCurrentNode];\n                                }\n                            }\n                        } // iPredVar != -1\n                        else // not interested in this split, average left and right \n                        {\n                            aiNodeStack[cStackNodes] = aiRightNode[iCurrentNode];\n                            dCurrentW = adWeightStack[cStackNodes];\n                            adWeightStack[cStackNodes] = dCurrentW *\n                                adW[aiRightNode[iCurrentNode]]/\n                                (adW[aiLeftNode[iCurrentNode]]+\n                                 adW[aiRightNode[iCurrentNode]]);\n                            cStackNodes++;\n                            aiNodeStack[cStackNodes] = aiLeftNode[iCurrentNode];\n                            adWeightStack[cStackNodes] = \n                                    dCurrentW-adWeightStack[cStackNodes-1];\n                            cStackNodes++;\n                        }\n                    } // non-terminal node\n                } // while(cStackNodes > 0)\n            } // iObs\n        } // iClass\n    } // iTree\n\nCleanup:\n    UNPROTECT(1); // radPredF\n    return radPredF;\nError:\n    goto Cleanup;\n} // gbm_plot\n\nSEXP gbm_shrink_pred\n(\n   SEXP radX,\n   SEXP rcRows,\n   SEXP rcCols,\n   SEXP rcNumClasses,\n   SEXP racTrees,\n   SEXP rdInitF,\n   SEXP rTrees,\n   SEXP rCSplits,\n   SEXP raiVarType,\n   SEXP rcInteractionDepth,\n   SEXP radLambda\n)\n{\n   unsigned long hr = 0;\n   int iTree = 0;\n   int iPredictionIter = 0;\n   int iObs = 0;\n   int iClass = 0;\n   int i = 0;\n   int cRows = INTEGER(rcRows)[0];\n   int cNumClasses = INTEGER(rcNumClasses)[0];\n   double *adLambda = REAL(radLambda);\n   double dLambda = 0.0;\n   double dPred = 0.0;\n\n   SEXP rThisTree = NULL;\n   int *aiSplitVar = NULL;\n   double *adSplitCode = NULL;\n   int *aiLeftNode = NULL;\n   int *aiRightNode = NULL;\n   int *aiMissingNode = NULL;\n   double *adNodeW = NULL;\n   int iCurrentNode = 0;\n   double dX = 0.0;\n   int iCatSplitIndicator = 0;\n\n   SEXP rResult  = NULL;\n   SEXP radPredF = NULL;\n\n   // The predictions\n   double *adPredF = NULL;\n   // The shrunken predictions\n   double *adNodePred = NULL;\n   int *aiNodeStack = NULL;\n   unsigned long cNodeStack = 0;\n   int cMaxNodes = 1+3*(INTEGER(rcInteractionDepth)[0]);\n\n   adPredF = new double[cRows * cNumClasses];\n   if(adPredF == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n   for(iObs=0; iObs<cRows*cNumClasses; iObs++)\n   {\n      adPredF[iObs] = REAL(rdInitF)[0];\n   }\n\n   adNodePred = new double[cMaxNodes];\n   if(adNodePred == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n   aiNodeStack = new int[cMaxNodes];\n   if(aiNodeStack == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n\n   // allocate the predictions to return\n   PROTECT(rResult = allocVector(VECSXP, length(racTrees)));\n   if(rResult == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n\n   iPredictionIter = 0;\n   iTree = 0;\n   while(iPredictionIter < length(racTrees))\n   {\n      while(iTree < INTEGER(racTrees)[iPredictionIter] * cNumClasses)\n      {\n         for (iClass = 0; iClass < cNumClasses; iClass++)\n         {\n              rThisTree     = VECTOR_ELT(rTrees,iTree);\n              aiSplitVar    = INTEGER(VECTOR_ELT(rThisTree,0));\n              adSplitCode   = REAL   (VECTOR_ELT(rThisTree,1));\n              aiLeftNode    = INTEGER(VECTOR_ELT(rThisTree,2));\n              aiRightNode   = INTEGER(VECTOR_ELT(rThisTree,3));\n              aiMissingNode = INTEGER(VECTOR_ELT(rThisTree,4));\n              adNodeW       = REAL   (VECTOR_ELT(rThisTree,6));\n\n              // shrink the tree's predictions\n              aiNodeStack[0] = 0;\n              cNodeStack = 1;\n              for(i=0; i<cMaxNodes; i++)\n              {\n                  adNodePred[i] = R_NaN;\n              }\n              while(cNodeStack>0)\n              {\n                 i = aiNodeStack[cNodeStack-1];\n                 if(aiSplitVar[i]==-1)\n                 {\n                    adNodePred[i] = adSplitCode[i];\n                    cNodeStack--;\n                 }\n                 else if(ISNA(adNodePred[aiLeftNode[i]]))\n                 {\n                    aiNodeStack[cNodeStack] = aiLeftNode[i];\n                    cNodeStack++;\n                    aiNodeStack[cNodeStack] = aiRightNode[i];\n                    cNodeStack++;\n\n                    // check whether missing node is the same as parent node\n                    // occurs when X_i has no missing values\n                    if(adNodeW[i] != adNodeW[aiMissingNode[i]])\n                    {\n                       aiNodeStack[cNodeStack] = aiMissingNode[i];\n                       cNodeStack++;\n                    }\n                    else\n                    {\n                       adNodePred[aiMissingNode[i]] = 0.0;\n                    }\n                 }\n                 else\n                 {\n                    // compute the parent node's prediction\n                    adNodePred[i] = \n                       (adNodeW[aiLeftNode[i]]*adNodePred[aiLeftNode[i]] +\n                        adNodeW[aiRightNode[i]]*adNodePred[aiRightNode[i]]+\n                        adNodeW[aiMissingNode[i]]*adNodePred[aiMissingNode[i]])/\n                            adNodeW[i];\n                    cNodeStack--;\n                 }         \n              }\n\n              // predict for the observations\n              for(iObs=0; iObs<cRows; iObs++)\n              {\n                 iCurrentNode = 0;\n                 dPred = 0.0;\n                 dLambda = 1.0;\n\n                 while(aiSplitVar[iCurrentNode] != -1)\n                 {\n                    dPred += dLambda*\n                             (1-adLambda[aiSplitVar[iCurrentNode]])*\n                             adNodePred[iCurrentNode];\n                    dLambda *= adLambda[aiSplitVar[iCurrentNode]];\n               \n                    dX = REAL(radX)[aiSplitVar[iCurrentNode]*cRows + iObs];\n                    // missing?\n                    if(ISNA(dX))\n                    {\n                       iCurrentNode = aiMissingNode[iCurrentNode];\n                    }\n                    // continuous?\n                    else if(INTEGER(raiVarType)[aiSplitVar[iCurrentNode]] == 0)\n                    {\n                       if(dX < adSplitCode[iCurrentNode])\n                       {\n                          iCurrentNode = aiLeftNode[iCurrentNode];\n                       }\n                       else\n                       {\n                          iCurrentNode = aiRightNode[iCurrentNode];\n                       }\n                    }\n                    else // categorical\n                    {\n                       iCatSplitIndicator = INTEGER(\n                          VECTOR_ELT(rCSplits,\n                                     (int)adSplitCode[iCurrentNode]))[(int)dX];\n                       if(iCatSplitIndicator==-1)\n                       {\n                          iCurrentNode = aiLeftNode[iCurrentNode];\n                       }\n                       else if(iCatSplitIndicator==1)\n                       {\n                          iCurrentNode = aiRightNode[iCurrentNode];\n                       }\n                       else // categorical level not present in training\n                       {\n                          iCurrentNode = aiMissingNode[iCurrentNode];\n                       }\n                    }\n                 }\n                 dPred += dLambda*adNodePred[iCurrentNode];\n\n                 // add the shrunken prediction\n                 adPredF[iObs + iClass * cRows] += dPred; // add the prediction\n              } // iObs\n              iTree++;\n          } // iClass\n      } // iTree\n\n      PROTECT(radPredF = allocVector(REALSXP, cRows));\n      if(radPredF == NULL)\n      {\n         hr = GBM_OUTOFMEMORY;\n         goto Error;\n      }\n      for(iObs=0; iObs<cRows*cNumClasses; iObs++)\n      {\n         REAL(radPredF)[iObs] = adPredF[iObs];\n      }\n      SET_VECTOR_ELT(rResult,iPredictionIter,radPredF);\n      UNPROTECT(1); // radPredF\n\n      iPredictionIter++;\n   }\n\nCleanup:\n   if(adPredF!=NULL)\n   {\n      delete [] adPredF;\n      adPredF = NULL;\n   }\n   if(adNodePred!=NULL)\n   {\n      delete [] adNodePred;\n      adNodePred = NULL;\n   }\n   if(aiNodeStack!=NULL)\n   {\n      delete [] aiNodeStack;\n      aiNodeStack = NULL;\n   }\n\n   UNPROTECT(1); // rResult\n   return rResult;\nError:\n   goto Cleanup;\n}\n\nSEXP gbm_shrink_gradient\n(\n   SEXP radY,\n   SEXP radX,\n   SEXP rcRows,\n   SEXP rcCols,\n   SEXP rcNumClasses,\n   SEXP rcTrees,\n   SEXP rdInitF,\n   SEXP rTrees,\n   SEXP rCSplits,\n   SEXP raiVarType,\n   SEXP rcInteractionDepth,\n   SEXP radLambda\n)\n{\n   unsigned long hr = 0;\n   int iTree = 0;\n   \n   int iObs = 0;\n   int iLambda = 0;\n   int iNode = 0;   \n   int iClass = 0;\n   int cRows = INTEGER(rcRows)[0];\n   int cNumClasses = INTEGER(rcNumClasses)[0];\n   double *adY = REAL(radY);\n   double *adLambda = REAL(radLambda);\n   double dLambdaProduct = 0.0;\n   double dPred = 0.0;\n   double dNewPredTerm = 0.0;\n   double dDJDf = 0.0;\n   \n   // NB for K-Class\n   double *adProb = NULL;\n   double dDenom = 0.0;\n\n   SEXP rThisTree = NULL;\n   int *aiSplitVar = NULL;\n   double *adSplitCode = NULL;\n   int *aiLeftNode = NULL;\n   int *aiRightNode = NULL;\n   int *aiMissingNode = NULL;\n   double *adNodeW = NULL;\n   int iCurrentNode = 0;\n   double dX = 0.0;\n   int iCatSplitIndicator = 0;\n\n   SEXP rResult  = NULL;\n   SEXP radPredF = NULL;\n   SEXP rdObjective = NULL;\n   SEXP radGradient = NULL;\n\n   // The node predictions\n   double *adNodePred = NULL;\n   // tracks which variables are in the prediction path\n   int *aiInPath = NULL;\n   int cInPath = 0;\n   double *adDfDLambda = NULL;\n   \n   adDfDLambda = new double[length(radLambda)];\n   if(adDfDLambda == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n   aiInPath = new int[INTEGER(rcInteractionDepth)[0]+1];\n   if(aiInPath == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n   // allocate the predictions to return\n   PROTECT(rResult = allocVector(VECSXP, 3));\n   if(rResult == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n   // allocate predictions\n   PROTECT(radPredF = allocVector(REALSXP, cRows * cNumClasses));\n   if(radPredF == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n   SET_VECTOR_ELT(rResult,0,radPredF);\n   UNPROTECT(1); // radPredF\n   //allocate objective function\n   PROTECT(rdObjective = allocVector(REALSXP, 1));\n   if(rdObjective == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n   SET_VECTOR_ELT(rResult,1,rdObjective);\n   UNPROTECT(1); // rdObjective\n   //allocate objective function\n   PROTECT(radGradient = allocVector(REALSXP, length(radLambda)));\n   if(radGradient == NULL)\n   {\n      hr = GBM_OUTOFMEMORY;\n      goto Error;\n   }\n   SET_VECTOR_ELT(rResult,2,radGradient);\n   UNPROTECT(1); // radGradient\n\n   // Allocate K-Class array\n   if (cNumClasses > 1)\n   {\n      adProb = new double[cNumClasses];\n   }\n\n   // initialize the predicted values\n   for(iObs=0; iObs<cRows*cNumClasses; iObs++)\n   {\n      REAL(radPredF)[iObs] = REAL(rdInitF)[0];\n   }\n   // initialize the gradient\n   for(iLambda=0; iLambda<length(radGradient); iLambda++)\n   {\n      REAL(radGradient)[iLambda] = 0.0;\n   }\n   REAL(rdObjective)[0] = 0.0;\n   \n   // predict for the observations\n   // first loop has to be over observations in order to compute the gradient\n   for(iObs=0; iObs<cRows; iObs++)\n   {\n       for(iLambda=0; iLambda<length(radGradient); iLambda++)\n       {\n           adDfDLambda[iLambda] = 0.0;\n       }\n     \n   \t   for(iTree=0; iTree<INTEGER(rcTrees)[0]; iTree++)\n         {\n            for (iClass = 0; iClass < cNumClasses; iClass++)\n            { \n\n               rThisTree     = VECTOR_ELT(rTrees,iClass + iTree * cNumClasses);\n               aiSplitVar    = INTEGER(VECTOR_ELT(rThisTree,0));\n               adSplitCode   = REAL   (VECTOR_ELT(rThisTree,1));\n               aiLeftNode    = INTEGER(VECTOR_ELT(rThisTree,2));\n               aiRightNode   = INTEGER(VECTOR_ELT(rThisTree,3));\n               aiMissingNode = INTEGER(VECTOR_ELT(rThisTree,4));\n               adNodeW       = REAL   (VECTOR_ELT(rThisTree,6));\n               adNodePred    = REAL   (VECTOR_ELT(rThisTree,7));\n\n               iCurrentNode = 0;\n               dPred = 0.0;\n               dLambdaProduct = 1.0;\n\n       \t      // reset for the new tree\n               cInPath = 0;\n\n               while(aiSplitVar[iCurrentNode] != -1)\n               {\n                  dNewPredTerm = dLambdaProduct*\n                                 (1-adLambda[aiSplitVar[iCurrentNode]])*\n                                 adNodePred[iCurrentNode];\n            \n                  // update prediction\n   \t            dPred += dNewPredTerm;\n             \n   \t            // update gradient\n   \t            if(adLambda[aiSplitVar[iCurrentNode]]!=1.0)\n                  {\n                     adDfDLambda[aiSplitVar[iCurrentNode]] -= \n                        dNewPredTerm/(1.0-adLambda[aiSplitVar[iCurrentNode]]);\n                  }\n   \t            for(iNode=0; iNode<cInPath; iNode++)\n                  {\n                     if(adLambda[aiInPath[iNode]]!=0.0)\n                     {\n                        adDfDLambda[aiInPath[iNode]] += \n                            dNewPredTerm/adLambda[aiInPath[iNode]];\n                     }\n                  } \n                  aiInPath[cInPath] = aiSplitVar[iCurrentNode];\n                  cInPath++;\n  \n                  dLambdaProduct *= adLambda[aiSplitVar[iCurrentNode]];\n             \n                  dX = REAL(radX)[aiSplitVar[iCurrentNode]*cRows + iObs];\n                  // missing?\n                  if(ISNA(dX))\n                  {\n                     iCurrentNode = aiMissingNode[iCurrentNode];\n                  }\n                  // continuous?\n                  else if(INTEGER(raiVarType)[aiSplitVar[iCurrentNode]] == 0)\n                  {\n                     if(dX < adSplitCode[iCurrentNode])\n                     {\n                        iCurrentNode = aiLeftNode[iCurrentNode];\n                     }\n                     else\n                     {\n                        iCurrentNode = aiRightNode[iCurrentNode];\n                     }\n                  } \n                  else // categorical\n                  {\n                     iCatSplitIndicator = INTEGER(\n                     VECTOR_ELT(rCSplits,\n                                (int)adSplitCode[iCurrentNode]))[(int)dX];\n                     if(iCatSplitIndicator==-1)\n                     {\n                        iCurrentNode = aiLeftNode[iCurrentNode];\n                     }\n                     else if(iCatSplitIndicator==1)\n                     {\n                        iCurrentNode = aiRightNode[iCurrentNode];\n                     }\n                     else // categorical level not present in training\n                     {\n                        iCurrentNode = aiMissingNode[iCurrentNode];\n                     }\n                  } \n               } // aiSplitVar[iCurrentNode] != -1\n\n               // incorporate the terminal node\n               dNewPredTerm = dLambdaProduct*adNodePred[iCurrentNode];\n               dPred += dNewPredTerm;\n               // update gradient\n               for(iNode=0; iNode<cInPath; iNode++)\n               {\n                  if(adLambda[aiInPath[iNode]] != 0.0)\n                  {\n                     adDfDLambda[aiInPath[iNode]] += \n                        dNewPredTerm/adLambda[aiInPath[iNode]];\n                  }\n               }\n\n               // add the prediction from tree iTree to prediction iObs\n               REAL(radPredF)[iObs + iClass * cRows] += dPred; \n           } // iClass\n       } // iTree\n       \n       // If multinomial was used (i.e. numClasses > 1) then calculate the probabilities\n       if (cNumClasses > 1)\n       {\n           dDenom = 0.0;\n           for (iClass = 0; iClass < cNumClasses; iClass++)\n           {\n               adProb[iClass] = exp(REAL(radPredF)[iObs + iClass * cRows]);\n               dDenom += adProb[iClass];\n           }\n\n           dDJDf = 0.0;\n           for (iClass = 0; iClass < cNumClasses; iClass++)\n           {\n               adProb[iClass] /= dDenom;\n\n               REAL(rdObjective)[0] += (adY[iObs + iClass * cRows] - adProb[iClass]) *\n                                       (adY[iObs + iClass * cRows] - adProb[iClass]);\n               dDJDf += -2*(adY[iObs + iClass * cRows] - adProb[iClass]);\n           }\n\n           REAL(rdObjective)[0] /= double(cNumClasses);\n           dDJDf /= double(cNumClasses);\n       }\n       else\n       {\n           // DEBUG: need to make more general for other loss functions!\n           REAL(rdObjective)[0] += (adY[iObs]-REAL(radPredF)[iObs])*\n                               (adY[iObs]-REAL(radPredF)[iObs]);\n           dDJDf = -2*(adY[iObs]-REAL(radPredF)[iObs]);\n       }\n      \n       for(iLambda=0; iLambda<length(radLambda); iLambda++)  \n       {\n           if(adDfDLambda[iLambda] != 0.0)\n           {\n               REAL(radGradient)[iLambda] += \n                  dDJDf * adDfDLambda[iLambda]; // * adLambda[iLambda]*(1.0-adLambda[iLambda]);\n           }\n       }\n   } // iObs\n\nCleanup:\n   if(adDfDLambda!=NULL)\n   {\n      delete [] adDfDLambda;\n      adDfDLambda = NULL;\n   }\n   if(aiInPath!=NULL)\n   {\n      delete [] aiInPath;\n      aiInPath = NULL;\n   }\n   if (adProb != NULL)\n   {\n       delete [] adProb;\n       adProb = NULL;\n   }\n   \n   UNPROTECT(1); // rResult\n   return rResult;\nError:\n   goto Cleanup;\n}\n\n} // end extern \"C\"\n\n",
    "created" : 1395633884140.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "292054888",
    "id" : "647E7309",
    "lastKnownWriteTime" : 1395632795,
    "path" : "C:/Users/Neil.Schneider/Repos/gbm/src/gbmentry.cpp",
    "project_path" : "src/gbmentry.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}