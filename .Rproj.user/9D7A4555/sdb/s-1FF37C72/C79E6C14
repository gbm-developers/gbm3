{
    "contents" : "predict.gbm <- function(object,newdata,n.trees,\n                        type=\"link\",\n                        single.tree = FALSE,\n                        ...)\n{\n   if ( missing( newdata ) ){\n      newdata <- reconstructGBMdata(object)\n   }\n   if ( missing(n.trees) ) {\n      if ( object$train.fraction < 1 ){\n         n.trees <- gbm.perf( object, method=\"test\", plot.it = FALSE )\n      }\n      else if (!is.null(object$cv.error)){\n         n.trees <- gbm.perf( object, method=\"cv\", plot.it = FALSE )\n      }\n      else{ best <- length( object$train.error ) }\n      cat( paste( \"Using\", n.trees, \"trees...\\n\" ) )\n   }\n   else if (length(n.trees) == 0){\n      stop(\"n.trees cannot be NULL or a vector of zero length\")\n   }\n\n   if(!is.element(type, c(\"link\",\"response\" )))\n   {\n      stop(\"type must be either 'link' or 'response'\")\n   }\n   if(!is.null(object$Terms))\n   {\n      x <- model.frame(terms(reformulate(object$var.names)),\n                       newdata,\n                       na.action=na.pass)\n   }\n   else\n   {\n      x <- newdata\n   }\n\n   cRows <- nrow(x)\n   cCols <- ncol(x)\n\n   for(i in 1:cCols)\n   {\n      if(is.factor(x[,i]))\n      {\n        if (length(levels(x[,i])) > length(object$var.levels[[i]])) {\n          new.compare <- levels(x[,i])[1:length(object$var.levels[[i]])]\n        } else {\n          new.compare <- levels(x[,i])\n        }\n        if (!identical(object$var.levels[[i]], new.compare)) {\n          x[,i] <- factor(x[,i], union(object$var.levels[[i]], levels(x[,i])))\n        }\n        x[,i] <- as.numeric(x[,i])-1\n      }\n   }\n\n   x <- as.vector(unlist(x, use.names=FALSE))\n   if(missing(n.trees) || any(n.trees > object$n.trees))\n   {\n      n.trees[n.trees>object$n.trees] <- object$n.trees\n      warning(\"Number of trees not specified or exceeded number fit so far. Using \",paste(n.trees,collapse=\" \"),\".\")\n   }\n   i.ntree.order <- order(n.trees)\n\n   # Next if block for compatibility with objects created with version 1.6.\n   if (is.null(object$num.classes)){\n       object$num.classes <- 1\n   }\n\n   predF <- .Call(\"gbm_pred\",\n                  X=as.double(x),\n                  cRows=as.integer(cRows),\n                  cCols=as.integer(cCols),\n                  cNumClasses = as.integer(object$num.classes),\n                  n.trees=as.integer(n.trees[i.ntree.order]),\n                  initF=object$initF,\n                  trees=object$trees,\n                  c.split=object$c.split,\n                  var.type=as.integer(object$var.type),\n                  single.tree = as.integer(single.tree),\n                  PACKAGE = \"gbm\")\n\n   if((length(n.trees) > 1) || (object$num.classes > 1))\n   {\n      if(object$distribution$name==\"multinomial\")\n      {\n         predF <- array(predF, dim=c(cRows,object$num.classes,length(n.trees)))\n         dimnames(predF) <- list(NULL, object$classes, n.trees)\n         predF[,,i.ntree.order] <- predF\n      } else\n      {\n         predF <- matrix(predF, ncol=length(n.trees), byrow=FALSE)\n         colnames(predF) <- n.trees\n         predF[,i.ntree.order] <- predF\n      }\n   }\n\n   if(type==\"response\")\n   {\n      if(is.element(object$distribution$name, c(\"bernoulli\", \"pairwise\")))\n      {\n         predF <- 1/(1+exp(-predF))\n      } else\n      if(object$distribution$name==\"poisson\")\n      {\n         predF <- exp(predF)\n      }\n      else if (object$distribution$name == \"adaboost\"){\n         predF <- 1 / (1 + exp(-2*predF))\n      }\n      if(object$distribution$name==\"multinomial\")\n      {\n         pexp <- exp(predF)\n         psum  <- apply(pexp,  c(1, 3), function(x) { x / sum(x) })\n         # Transpose each 2d array\n         predF <- aperm(psum, c(2, 1, 3))\n      }\n\n      if((length(n.trees)==1) && (object$distribution$name!=\"multinomial\"))\n      {\n         predF <- as.vector(predF)\n      }\n   }\n\n   if(!is.null(attr(object$Terms,\"offset\")))\n   {\n      warning(\"predict.gbm does not add the offset to the predicted values.\")\n   }\n\n   return(predF)\n}\n",
    "created" : 1395539570232.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3793615733",
    "id" : "C79E6C14",
    "lastKnownWriteTime" : 1394831783,
    "path" : "C:/Users/Neil.Schneider/Repos/gbm/R/predict.gbm.R",
    "project_path" : "R/predict.gbm.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}