{
    "contents" : ".onAttach <- function(lib, pkg)\n{\n   vers <- library(help=gbm)$info[[1]]\n   vers <- vers[grep(\"Version:\",vers)]\n   vers <- rev(strsplit(vers,\" \")[[1]])[1]\n   packageStartupMessage(paste(\"Loaded gbm\",vers))\n}\n\ngbm <- function(formula = formula(data),\n                distribution = \"bernoulli\",\n                data = list(),\n                weights,\n                subset = NULL,\n                offset,\n                var.monotone = NULL,\n                n.trees = 100,\n                interaction.depth = 1,\n                n.minobsinnode = 10,\n                shrinkage = 0.001,\n                bag.fraction = 0.5,\n                train.fraction = 1.0,\n                mFeatures = NULL,\n                cv.folds=0,\n                keep.data = TRUE,\n                verbose = 'CV',\n                class.stratify.cv=NULL,\n                n.cores=NULL){\n   theCall <- match.call()\n\n\n   lVerbose <- if (!is.logical(verbose)) { FALSE }\n               else { verbose }\n\n   mf <- match.call(expand.dots = FALSE)\n   m <- match(c(\"formula\", \"data\", \"weights\", \"subset\", \"offset\"), names(mf), 0)\n   mf <- mf[c(1, m)]\n   mf$drop.unused.levels <- TRUE\n   mf$na.action <- na.pass\n   mf[[1]] <- as.name(\"model.frame\")\n   m <- mf\n   mf <- eval(mf, parent.frame())\n   Terms <- attr(mf, \"terms\")\n   y <- model.response(mf)\n\n   if (missing(distribution)){ distribution <- guessDist(y) }\n   else if (is.character(distribution)){ distribution <- list(name=distribution) }\n\n   w <- model.weights(mf)\n   offset <- model.offset(mf)\n\n   # get the character name of the response variable\n   response.name <- as.character(formula[[2]])\n   \n   var.names <- attributes(Terms)$term.labels\n   x <- model.frame(terms(reformulate(var.names)),\n                    data,\n                    na.action=na.pass,\n                    subset=subset)\n\n#  x <- mf[, !is.element(names(mf), response.name)]\n\n   lVerbose <- if (!is.logical(verbose)) { FALSE }\n               else { verbose }\n\n   class.stratify.cv <- getStratify(class.stratify.cv, distribution)\n\n   # groups (for pairwise distribution only)\n   group      <- NULL\n   num.groups <- 0\n\n   # determine number of training instances\n   if (distribution$name != \"pairwise\"){\n      nTrain <- floor(train.fraction * nrow(x))\n   }\n   else {\n      # distribution$name == \"pairwise\":\n      # Sampling is by group, so we need to calculate them here\n      distribution.group <- distribution[[\"group\"]]\n      if (is.null(distribution.group))\n      {\n         stop(\"For pairwise regression, the distribution parameter must be a list with a parameter 'group' for the a list of the column names indicating groups, for example list(name=\\\"pairwise\\\",group=c(\\\"date\\\",\\\"session\\\",\\\"category\\\",\\\"keywords\\\")).\")\n      }\n\n      # Check if group names are valid\n      i <- match(distribution.group, colnames(data))\n      if (any(is.na(i)))\n      {\n         stop(\"Group column does not occur in data: \", distribution.group[is.na(i)])\n      }\n\n      # Construct group index\n      group <- factor(do.call(paste, c(data[,distribution.group, drop=FALSE], sep=\":\")))\n\n      # Check that weights are constant across groups\n      if ((!missing(weights)) && (!is.null(weights)))\n      {\n         w.min <- tapply(w, INDEX=group, FUN=min)\n         w.max <- tapply(w, INDEX=group, FUN=max)\n\n         if (any(w.min != w.max))\n         {\n            stop(\"For distribution 'pairwise', all instances for the same group must have the same weight\")\n         }\n\n         # Normalize across groups\n         w <- w * length(w.min) / sum(w.min)\n      }\n\n      # Shuffle groups, to remove bias when splitting into train/test set and/or CV folds\n      perm.levels  <- levels(group)[sample(1:nlevels(group))]\n      group        <- factor(group, levels=perm.levels)\n\n      # The C function expects instances to be sorted by group and descending by target\n      ord.group    <- order(group, -y)\n      group        <- group[ord.group]\n      y            <- y[ord.group]\n      x            <- x[ord.group,,drop=FALSE]\n      w            <- w[ord.group]\n\n      # Split into train and validation set, at group boundary\n      num.groups.train <- max(1, round(train.fraction * nlevels(group)))\n\n      # include all groups up to the num.groups.train\n      nTrain           <- max(which(group==levels(group)[num.groups.train]))\n      Misc             <- group\n   } # close if(distribution$name==\"coxph\") ...\n\n    #Determine the number of features to consider at each node\n    if (is.null(mFeatures)) {\n      mFeatures <- ncol(x)\n    } else {\n      if (mFeatures > ncol(x)) {\n        print(\"mFeatures was greater than the number of columns. It was reset to the available features.\")\n        mFeatures <- ncol(x)\n      } else {\n        mFeatures <- max(mFeatures, 1)\n      }\n    }\n\n   cv.error <- NULL\n   if(cv.folds>1) {\n     cv.results <- gbmCrossVal(cv.folds, nTrain, n.cores,\n                               class.stratify.cv, data,\n                               x, y, offset, distribution, w, var.monotone,\n                               n.trees, interaction.depth, n.minobsinnode,\n                               shrinkage, bag.fraction, mFeatures,\n                               var.names, response.name, group)\n     cv.error <- cv.results$error\n     p <- cv.results$predictions\n   } # Close if(cv.folds > 1\n\n   gbm.obj <- gbm.fit(x,y,\n                      offset = offset,\n                      distribution = distribution,\n                      w = w,\n                      var.monotone = var.monotone,\n                      n.trees = n.trees,\n                      interaction.depth = interaction.depth,\n                      n.minobsinnode = n.minobsinnode,\n                      shrinkage = shrinkage,\n                      bag.fraction = bag.fraction,\n                      nTrain = nTrain,\n                      mFeatures = mFeatures,\n                      keep.data = keep.data,\n                      verbose = lVerbose,\n                      var.names = var.names,\n                      response.name = response.name,\n                      group = group)\n\n   gbm.obj$train.fraction <- train.fraction\n   gbm.obj$Terms <- Terms\n   gbm.obj$cv.error <- cv.error\n   gbm.obj$cv.folds <- cv.folds\n   gbm.obj$call <- theCall\n   gbm.obj$m <- m\n   if (cv.folds > 1){ gbm.obj$cv.fitted <- p }\n\n   if (distribution$name == \"pairwise\")\n   {\n      # Data has been reordered according to queries.\n      # We need to permute the fitted values to correspond\n      # to the original order.\n      gbm.obj$ord.group <- ord.group\n      gbm.obj$fit <- gbm.obj$fit[order(ord.group)]\n   }\n\n   return(gbm.obj)\n}\n",
    "created" : 1395538847014.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "206394736",
    "id" : "617D1A87",
    "lastKnownWriteTime" : 1395626241,
    "path" : "C:/Users/Neil.Schneider/Repos/gbm/R/gbm.R",
    "project_path" : "R/gbm.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}